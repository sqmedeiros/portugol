\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{url}
\usepackage{gensymb}   %comando \degree
\usepackage{verbatim}  %para comentar de múltiplas linhas

\newcommand{\Qgol}{QuoGol\;}

\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{center}
%\tt{LabLua}\\
%\tt{www.lua.inf.puc-rio.br}
\end{center}
\vspace{6cm}
\Huge{Lógica de Programação}\\
\vspace{1.5cm}
\Large{Sérgio Queiroz de Medeiros} \\
\Large{Escola de Ciências e Tecnologia} \\
\Large{UFRN}
\vspace{5cm}
\\
\large{Agosto de 2016}
\end{center}

%\tableofcontents

\pagebreak

%\textbf{\huge{Prefácio}}

%\vspace{1cm}


\chapter{Introdução}

Em um curso como Lógica de Programação, onde o aluno
vai começar o aprendizado de algoritmos e de programação
de computadores, é comum a utilização de uma linguagem
de programação que possa facilitar o entendimento do
assunto, ao invés de usar linguagens de programação
mais convencionais.

Geralmente uma linguagem de programação utiliza termos em inglês,
de modo que ela possa ser usada por pessoas de todo o mundo.
Contudo, o uso de termos em inglês pode dificultar o aprendizado
de alguns alunos. Por conta disso, algumas linguagens, voltadas
principalmente para o aprendizado de programação, usam termos em
português. Essas linguagens são usualmente chamadas de \emph{Portugol}.

Neste curso utilizaremos a linguagem de programação \emph{\Qgol},
cuja sintaxe foi inspirada na sintaxe da linguagem Quorum
(\url{https://www.quorumlanguage.com/}).

Com \Qgol será possível implementarmos algoritmos que envolvam
estruturas de decisão, estruturas de repetição, coleções de dados
e funções.

Para executarmos os programas escritos em \Qgol é necessário
instalar o ambiente de programação da linguagem, que está disponível em
\url{https://github.com/alex7alves/Setup-QuoGol-IDE}.


\section{Programa \emph{Olá, mundo}}

Vamos começar o nosso aprendizado com um programa \Qgol simples,
que imprime um texto:
%
\begin{verbatim}
escreva("Olá, mundo")
\end{verbatim}
%
No programa acima usamos a função \texttt{escreva},
que recebe um valor entre parênteses e o imprime para
a saída padrão do computador (o monitor, geralmente).
Nesse programa o valor recebido por \texttt{escreva}
foi um texto, delimitado por aspas duplas. Quando executado,
esse programa imprime \emph{Olá, mundo}.  

Escreva o programa acima no ambiente de programação de \Qgol,
salve o arquivo como \texttt{alo.gol} e tente executá-lo.
Use sempre a extensão \texttt{.gol} para os arquivos com
programas \Qgol.

A função \texttt{escreva} não imprime só texto, ela também
imprime valores inteiros e outros tipos de dados que veremos
mais adiante. Por exemplo, no programa a seguir a função
\texttt{escreva} recebe dois valores, um texto e o valor
inteiro 42:
%
\begin{verbatim}
escreva("A resposta é ", 42)
\end{verbatim}
%
Note que usamos uma vírgula para separar os
valores passados para a função \texttt{escreva}.


\section{Fazendo contas}

Podemos usar \Qgol como uma calculadora, onde a função
\texttt{escreva} irá imprimir o resultado de uma determinada
expressão, como no exemplo abaixo:
%
\begin{verbatim}
escreva("A resposta é ", 1 + 1)
\end{verbatim}
%
Nesse exemplo, a expressão \texttt{1 + 1} terá seu valor
calculado e então esse valor será exibido. Podemos calcular
também o resultado de expressões mais complexas:
\begin{verbatim}
escreva("A resposta é ", 3 + 4 * 5)
\end{verbatim}
% 
Nesse caso, como o operador \textbf{*} possui maior precedência
a multiplicação \texttt{4 * 5} será realizada primeiro e o seu
resultado será somado ao valor 3.
%
Para mudar a ordem em que as operações devem ser feitas podemos
usar parênteses, como no exemplo a seguir:
\begin{verbatim}
escreva("Usando parênteses ", (3 + 4) * 5, (5 + 7)  / (3 - 1))
\end{verbatim}
%
Esse programa deve imprimir os valores 35 e 6 como resultado
das operações de multiplicação e divisão, respectivamente.


\section{Variáveis}

Nos programas anteriores fizemos operações com literais, isto é,
valores que já estavam definidos no próprio programa (os números $3$, $7$, etc).
Agora vamos escrever um programa que vai pedir para o usuário
digitar valores e então vai fazer operações sobre esses valores.

Esse programa requer que as informações digitadas pelo usuário sejam
armazenadas e para isso vamos usar variáveis. Uma variável é um nome associado
a uma região da memória do computador. Podemos usar esse nome para
acessar e alterar o valor armazenado nessa região de memória. 

Abaixo, temos o programa \texttt{somaInteiro.gol}, que
calcula a soma de valores inteiros digitados pelo usuário:
%
\begin{verbatim}
01  inteiro valor1, valor2, soma
02
03  escreva("Digite um valor inteiro: ")
04  leia(valor1)
05
06  escreva("Digite outro valor inteiro: ")
07  leia(valor2)
08
09  soma = valor1 + valor2
10  escreva("A soma deu ", soma)
\end{verbatim}
%
Na linha 1 declaramos as variáveis \texttt{valor1}, \texttt{valor2}
e \texttt{soma}, do tipo \textbf{inteiro}. Em \Qgol
toda variável possui um tipo, que indica a natureza dos valores que
iremos armazenar naquela variável. No exemplo acima, o tipo \textbf{inteiro} indica
que iremos guardar valores inteiros, tais como 42, -255, 0 e 1000000,
nas variáveis \texttt{valor1}, \texttt{valor2} e \texttt{soma}.

Toda variável deve ser declarada antes de ser usada. Para declarar
uma variável devemos informar o tipo e o nome da variável.
 
Na linha 3, usamos a função \texttt{escreva}, que vimos anteriormente,
para pedir que o usuário forneça um valor inteiro.

Usamos a função \texttt{leia} na linha 4 para ler a informação digitada
pelo usuário e armazená-la na região de memória associada à variável
\texttt{valor1}. De modo similar, na linha 7 usamos \texttt{leia}
para guardar na variável\texttt{valor2} o segundo valor inteiro
digitado pelo usuário.

Na linha 9, usamos o operador de atribuição \textbf{=} para guardar
na variável \texttt{soma} o resultado da operação \texttt{valor1 + valor2},
que é um valor inteiro. Mais adiante iremos estudar a precedência dos
operadores, que determina que operações serão realizadas primeiro.
No caso da linha 9, primeiro será realizada a operação \textbf{+} (soma)
e depois a operação \textbf{=} (atribuição).

Em seguida, na linha 10, imprimimos um texto seguido do valor armazenado
em \texttt{soma}. 

Digite o programa \Qgol acima no seu ambiente de programação
e depois o execute. Em seguida, modifique o programa de modo que
ele imprima também o valor da subtração \texttt{valor1 - valor2}.



\section{Operadores Aritméticos}

Abaixo listamos os operadores aritméticos disponíveis em \Qgol,
os quais são todos operadores binários:
\begin{verbatim}
+   -   *   /   mod
\end{verbatim}


O operador \textbf{/} calcula o resultado da divisão entre dois valores
$x$ e $y$. Se $x$ e $y$ são valores inteiros, então o resultado será um
valor inteiro. Por exemplo, a expressão abaixo:
\begin{verbatim}
12 / 5
\end{verbatim}
produzirá o valor 2.

Se um dos valores for um número real, como por exemplo 3.14\footnote{Note que devemos
usar o ponto ao invés da vírgula para separar a parte inteira da parte fracionária de um número.},
então o resultado será um número real. Por exemplo, a expressão:
\begin{verbatim}
12 / 5.0
\end{verbatim}
produzirá o valor 2.4.

Para armazenar um valor real, devemos usar uma variável do tipo
\textbf{numero}, como mostrado no exemplo abaixo:
\begin{verbatim}
01  numero x = 12 / 5
02  escreva("x = ", x)
03
04  x = 12 / 5.0
05  escreva("x = ", x)
\end{verbatim}
%
Na linha 1 declaramos a variável \texttt{x} e a inicializamos
com o valor da expressão \texttt{12 / 5}. Na linha 2 imprimimos
o valor de \texttt{x}, no caso 2. Note que uma variável do tipo
\textbf{numero} também pode guardar valores inteiros, porém uma
variável do tipo \textbf{inteiro} não pode guardar valores reais.

Na linha 4, atribuímos a \texttt{x} o valor da expressão \texttt{12 / 5.0}
e na linha 5 imprimimos o novo valor de \texttt{x}.

Enquanto o operador \textbf{/} nos dá o resultado do quociente
de uma divisão, o opererador \textbf{mod} nos dá o resto de uma
divisão. Por exemplo, o resultado da expressão
\begin{verbatim}
14 mod 5
\end{verbatim}
é 4, que representa o resto da divisão de 14 por 5.

Ao contrário dos outros operadores aritméticos, que aceitam
valores reais e inteiros, o operador \textbf{mod} somente pode
ser aplicado a operandos inteiros. 

O operador \textbf{mod} é bastante útil se desejamos saber se
um número é ou não divisível por outro. Quando um número é divisível
por outro o resultado do operador \textbf{mod} é zero.

Abaixo, temos um programa que lê dois números inteiros \texttt{x} e \texttt{y}
e imprime \texttt{verdadeiro} se \texttt{x} é divisível por \texttt{y}, e
\textbf{falso} caso contrário:
%
\begin{verbatim}
01  inteiro x, y
02  
03  escreva("Digite dois valores inteiros: ")
04  leia(x, y)
05 
06  inteiro resto = x mod y
07  escreva(x,  " divisível por ",  y, "? ", resto == 0)
\end{verbatim}

Na linha 1 declaramos as variáveis inteiras \texttt{x}, \texttt{y},
e na linha 4 fazemos a leitura dos valores de \texttt{x} e \texttt{y}.

Em seguida, na linha 6, declaramos e inicializamos a variável \texttt{resto}
como o resto da divisão de \texttt{x} por \texttt{y}. Na linha 7 usamos o
operador de igualdade \textbf{==}. A expressão \texttt{resto == 0} produzirá
um valor booleano, isto é, um valor verdadeiro (quando \texttt{resto} for igual a zero)
ou falso (quando \texttt{resto} for diferente de zero). 

Note que no programa anterior não guardamos o resultado da expressão
\texttt{resto == 0} em uma variável, ao invés disso imprimimos diretamente
o valor dessa expressão. Claro que também poderíamos guardar o valor dessa
expressão em uma variável, e então imprimir o valor dessa variável. Nesse
caso, precisaríamos usar uma variável do tipo \textbf{booleano}. A seguir
listamos os tipos disponíveis em \Qgol e qual informação podemos armazenar
em uma variável de cada tipo:

\begin{itemize}
	\item \textbf{booleano}: representa os valores \textbf{verdadeiro} e \textbf{falso}
	\item \textbf{inteiro}: representa valores inteiros, como 101, -93 e 0
	\item \textbf{numero}: representa valores reais, como 3.14, -10.4, e 42.0
	\item \textbf{texto}: representa sequências de caracteres, que devem estar entre
  aspas duplas, tais como "bola" e "ciclo básico"
\end{itemize}

% TODO: falar da função de conversão entre inteiros e reais


\section{Conversão de Temperaturas}

Dado que sabemos como realizar operações aritméticas em \Qgol,
podemos escrever um programa que converte temperaturas. Em todo o
mundo as temperaturas são medidas na escala Celsius, porém os
Estados Unidos ainda usam uma escala diferente, e medem a temperatura
em graus Fahrenheit. 

A nossa tarefa é fazer um programa que converte uma temperatura em
graus Celsius (ou centígrados) para Fahrenheit.

Não adianta tentar escrever um programa para isso se não sabemos
como converter uma temperatura entre essas duas escalas.

Na escala Celsius a água congela a 0\degree e ferve a 100\degree C,
enquanto que na escala Fahrenheit ela congela a 32\degree
e ferve a 212\degree F.

Com isso, podemos definir uma regra de conversão entre essas escalas
da seguinte maneira, onde \texttt{C} representa uma temperatura qualquer
em graus Celsius e \texttt{F} representa uma temperatura qualquer em
graus Fahrenheit:
\[
\frac{F-32}{212-32} = \frac{C-0}{100-0}  \;\;\Rightarrow\;\;  \frac{F-32}{180}  =  \frac{C}{100}
\]
Podemos dividir ambos os lados da igualdade por 20 e então obter a equação:
\[
\frac{F-32}{9} = \frac{C}{5}  \;\;\Rightarrow\;\;  F = \frac{9*C}{5} + 32
\]

Agora que sabemos como converter uma temperatura na escala Celsius para a
correspondente na escala Fahrenheit podemos escrever o nosso programa \Qgol,
que está listado na figura~\ref{fig:celsius}:

\begin{figure}
\begin{verbatim}
01  //Programa que converte de Celsius para Fahrenheit
02
03  numero tempC, tempF
04
05  escreva("Digite uma temperatura em graus Celsius: ")
06  leia(tempC)
07
08  tempF = (tempC * 9) / 5  +  32
09
10  escreva(tempC, "C  equivalem a ", tempF, "F")
\end{verbatim}
\caption{Programa que converte uma temperatura em graus Celsius para Fahrenheit}
\label{fig:celsius}
\end{figure}

Na linha 1 do programa temos um comentário de uma linha. Um comentário é indicado
por \texttt{//} e não faz parte da lógica do programa, é apenas uma informação para
o programador, muitas vezes usado para explicar o que faz um certo trecho de código.
O texto de um comentário é ignorado pelo compilador ao gerar um arquivo executável.

Na linha 3 declaramos as variáveis \texttt{tempC} e \texttt{tempF} para armazenar
os valores das temperaturas em graus Celsius e Fahrenheit, respectivamente. Note
que elas são do tipo \texttt{numero}, não do tipo \texttt{inteiro}, pois podemos
representar uma temperatura como um valor real.

Na linha 6 inicializamos a variável \texttt{tempC} com o valor fornecido pelo usuário.
Em seguida, na linha 8, convertemos a temperatura para Fahrenheit de acordo com a
equação mostrada anteriormente.

Por fim, na linha 10, imprimimos o valor da temperatura nas duas escalas.

Se fornecermos como entrada do programa a temperatura prevista para hoje em Natal,
que é de 29\degree C, ele mostrará o valor correspondente de 84.2\degree F.


\section{Exercícios}

\begin{enumerate}

\item Escreva um programa que converte um valor em dólares
	para o valor correspondente em reais. O seu programa deve
	ler a quantidade de dólares que se deseja converter, a taxa
	de conversão, e então imprimir o valor equivalente em reais.
\begin{itemize}
	\item Exemplo de entrada:
\begin{verbatim}
100 3.5
\end{verbatim}
	\item Exemplo de saída:
\begin{verbatim}
U$$ 100 equivalem a R$ 350 
\end{verbatim}
\end{itemize}


\item Escreva um programa que dada uma quantidade $S$ de
	segundos calcula e imprime a quantidade correspondente
	de horas, minutos e segundos.
\begin{itemize}
	\item Exemplos de entrada:
\begin{verbatim}
201
3670
\end{verbatim}
	\item Exemplos de saída:
\begin{verbatim}
O hora(s), 3 minuto(s) e 21 segundo(s) 
1 hora(s), 1 minuto(s) e 10 segundo(s)
\end{verbatim}
\end{itemize}

		\item Dado um número inteiro $n$, imprima
		os três últimos dígitos de $n$ separados
		por espaços.

\begin{itemize}
	\item Exemplos de entrada:
\begin{verbatim}
1234
56
\end{verbatim}

	\item Exemplos de saída:
\begin{verbatim}
2  3  4
0  5  6
\end{verbatim}
\end{itemize}

\begin{comment}
\item Considere que um caixa de supermercado possui notas de R\$ 50,
R\$ 20, R\$ 10, R\$ 5 e R\$ 1. Escreva um programa que lê um valor
inteiro, que representa o troco que o caixa deve dar, e calcula o
menor número de notas que o caixa deve utilizar para obter esse valor.
O programa deve mostrar o número de notas de cada valor que serão
utilizados para fornecer o troco.
\begin{itemize}
	\item Exemplo de entrada:
\begin{verbatim}
87
\end{verbatim}
	\item Exemplo de saída:
\begin{verbatim}
1 nota(s) de R$ 50
1 nota(s) de R$ 20
1 nota(s) de R$ 10
1 nota(s) de R$  5
2 nota(s) de R$  1
\end{verbatim}
\end{itemize}
\end{comment}
\end{enumerate}



\section{Operadores Relacionais e Lógicos}

Além dos operadores aritméticos, em \Qgol também temos operadores
relacionais e lógicos.

Já vimos um exemplo de operador relacional, o operador de igualdade
\textbf{==}. Todos os operadores de igualdade possuem dois operandos
e produzem os valores \textbf{verdadeiro} ou \textbf{falso}. Abaixo
listamos todos os operadores relacionais, onde \textbf{nao=} é o
operador de negação da igualdade:
\begin{verbatim}
==   nao=   <   >   <=   >=
\end{verbatim}

Podemos aplicar os operadores \textbf{==} e \textbf{nao=} a qualquer
tipo de valor, isto é podemos aplicá-lo a valores inteiros, reais,
booleanos e textuais. Os operadores de ordem {\bf <}, {\bf >}, {\bf <=} e {\bf >=}
podem ser aplicados a valores inteiros, reais e textuais, mas não podem ser
aplicados a valores booleanos. 

Para manipular valores booleanos devemos usar os operadores lógicos,
que também produzem como resultado um valor booleano.
Abaixo listamos os operadores lógicos de \Qgol, onde o operador
de conjunção (\textbf{e}) e o operador de disjunção (\textbf{ou})
são operadores binários, enquanto que o operador de negação (\textbf{nao})
é unário:
\begin{verbatim}
e   ou   nao
\end{verbatim}

Sejam \texttt{exp1} e \texttt{exp2} duas expressões booleanas (isto é,
duas expressões cujo valor é verdadeiro ou falso), o operador \textbf{e}
somente produzirá um valor verdadeiro quando ambas as expressões forem
verdadeiras. Podemos ver a tabela verdade para esse operador na
figura~\ref{tab:ope}.

\begin{figure}
\centering
\begin{tabular}{|l|l|l|}
\hline
exp1 & exp2 & exp1 {\bf e} exp2 \\ \hline
falso & falso & falso \\ \hline
falso & verdadeiro & falso \\ \hline
verdadeiro & falso & falso \\ \hline
verdadeiro & verdadeiro & verdadeiro \\ \hline
\end{tabular}
\caption{Tabela verdade para o operador lógico {\bf e} (conjunção)}
\label{tab:ope}
\end{figure}

Já a aplicação do operador \textbf{ou} resultará em um
valor verdadeiro quando uma das expressões for verdadeira,
como podemos ver na figura~\ref{tab:opou}, que apresenta
a tabela verdade correspondente a esse operador.

\begin{figure}
\centering
\begin{tabular}{|l|l|l|}
\hline
exp1 & exp2 & exp1 {\bf ou} exp2 \\ \hline
falso & falso & falso \\ \hline
falso & verdadeiro & verdadeiro \\ \hline
verdadeiro & falso & verdadeiro \\ \hline
verdadeiro & verdadeiro & verdadeiro \\ \hline
\end{tabular}
\caption{Tabela verdade para o operador lógico {\bf ou} (disjunção)}
\label{tab:opou}
\end{figure}

Os operadores \textbf{e} \,e\, \textbf{ou} fazem avaliação
de curto-circuito, isto é, eles só avaliam o seu segundo
operando quando necessário. No caso do \textbf{e}, o
segundo operando só é avaliado se o primeiro for verdadeiro,
caso contrário já é possível determinar que o resultado
da conjunção será falso. No caso do \textbf{ou}, o
segundo operando só é avaliado se o primeiro for falso,
caso contrário a disjunção será verdadeira.

O operador de negação \textbf{nao} inverte o valor da
expressão booleana sobre o qual é aplicado. Podemos
ver a sua tabela verdade na figura~\ref{tab:opnao},
onde \texttt{exp} representa uma expressão booleana.
\begin{figure}
\centering
\begin{tabular}{|l|l|}
\hline
exp & {\bf nao} exp  \\ \hline
falso & verdaeiro \\ \hline
verdadeiro & falso  \\ \hline
\end{tabular}
\label{tab:opnao}
\caption{Tabela verdade para o operador lógico {\bf nao} (negação)}
\end{figure}

O operador \textbf{nao} possui maior precedência do
que o \textbf{e}, que por sua vez possui maior precedência
do que o \textbf{ou}.

Vamos ver o uso desses operadores em um programa que imprime
verdadeiro ou falso dependendo se um aluno foi aprovado ou não
em uma disciplina. Assuma que o aluno recebeu a nota de duas
avaliações e para ser aprovado deve ter pelo menos uma nota
maior ou igual a 7 e não pode tirar nenhuma nota abaixo de 3.

Considerando que \texttt{nota1} e \texttt{nota2} são variáveis
com os valores da notas do aluno, a seguinte expressão booleana
verifica as condições de aprovação:
\begin{verbatim}
(nota1 >= 7.0 ou nota2 >= 7.0) e nao (nota1 < 3.0) e nao (nota2 < 3.0)
\end{verbatim} 
 
Note o uso de parênteses para forçar a ordem de avaliação desejada.
Uma outra maneira de expressar a condição acima seria como abaixo:
\begin{verbatim}
(nota1 >= 7.0 ou nota2 >= 7.0) e nota1 >= 3.0 e nota2 >= 3.0
\end{verbatim}

A figura~\ref{fig:aprovado} apresenta um programa que imprime
uma mensagem informando se um aluno foi aprovado ou não de
acordo com a condição acima.

\begin{figure}
{\small
\begin{verbatim}
01  numero nota1, nota2
02
03  escreva("Digite a nota da primeira avaliação: ")
04  leia(nota1)
05
06  escreva("Digite a nota da segunda avaliação: ")
07  leia(nota2)
08
09  booleano resultado
10  resultado = (nota1 >= 7.0 ou nota2 >= 7.0) e nao (nota1 < 3.0) e nao (nota2 < 3.0)
11
12  escreva("Aprovado? ", resultado) 
\end{verbatim}
\caption{Programa que verifica se um aluno foi aprovado}
\label{fig:aprovado}
}
\end{figure}

Na linha 1 declaramos duas variáveis do tipo \textbf{numero},
pois as notas de um aluno podem ser valores reias como 5.5 e 8.9.
Em seguida, nas linhas 3--7, fazemos a leitura das notas. Nas linhas
9 e 10 declaramos uma variável do tipo booleano e atribuímos a ela
o resultado da expressão que verifica a condição de aprovação. Por fim,
na linha 12 imprimimos o resultado.


\section{Exercícios}

\begin{enumerate}

\item Implemente um programa que recebe um valor inteiro
correspondente a um ano e imprime \textbf{verdadeiro} se
esse ano é bissexto e falso caso contrário. Um ano é bissexto
se ele é múltiplo de 4 mas não de 100, ou se ele é múltiplo de 400.
\begin{itemize}
	\item Exemplos de entrada:
\begin{verbatim}
2016
1900
2000
\end{verbatim}
	\item Exemplos de saída:
\begin{verbatim}
verdadeiro
falso
verdadeiro
\end{verbatim}
\end{itemize}

\end{enumerate}


\chapter{Estruturas de Controle}

\chapter{Estruturas de Repetição}



\section{Exercícios}




\section{Declaração de Array}

A forma geral para declarar um array é a seguinte: 
\begin{verbatim}
nomeDoTipo[] identificador
\end{verbatim}

No exemplo acima, apenas declaramos um array, mas não o
inicializamos. Abaixo declaramos e inicializamos um
array de inteiros com 10 elementos:
\begin{verbatim}
inteiro[] x = novo inteiro[10]
\end{verbatim}

O primeiro elemento de $x$ está no índice 1 o último
elemento no índice 10. É um erro acessar um índice do
array fora desse intervalo. Abaixo temos o exemplo de
um programa que inicializa cada posição $i$ de um array
com o $i^2$ e imprime o resultado:
\begin{verbatim}
inteiro[] a

a = novo inteiro[5]

inteiro i = 1
repita enquanto i <= 5
  a[i] = i * i
  i = i + 1
fim

i = 1
repita enquanto i <= 5
  escreva(a[i])
  i = i + 1
fim
\end{verbatim}


Devemos usar um par de \texttt{[]} para declarar cada dimensão
do nosso array, como mostrado abaixo: 
\begin{verbatim}
inteiro[][] x = novo inteiro[5][3]
\end{verbatim}

A expressão \texttt{novo inteiro[5][3]} diz que $x$ é um
array que possui 5 elementos na primeira dimensão, e cada
uma desses elementos possui 3 elementos na segunda dimensão.


\section{Funções Básicas}

\begin{itemize}
	\item \textbf{escreva (parâmetro1, parâmetro2, ..., parâmetroN)}
	
	\item \textbf{leia(parâmetro1, parâmetro2, ..., parâmetroN)}
	
	\item \textbf{inteiro textoComp (texto s)}: retorna o comprimento do texto $s$
	
	\item \textbf{texto textoSub (texto s, inteiro inicio, inteiro fim)}:
	retorna a porção do texto $s$ que começa no índice $inicio$ e termina
  no índice $fim$. O índice $fim$ é opcional, se ele não for fornecido a
  porção do texto $s$ retornada começa em $inicio$ e vai até o fim de $s$.
	
	\item \textbf{texto textoPos (texto s, inteiro inicio)}:
	retorna o texto no índice $inicio$ de $s$
\end{itemize}


\section{Declaração de Função}

Forma geral de declarar uma função: \\
\textbf{funcao} nomeFuncao (tipo1 nome1, ..., tipoN nomeN) \textbf{retorna} tipoRetorno

Caso a função não retorne nenhum valor, a última parte não é necessária e a
função pode ser declarada como: \\
\textbf{funcao} nomeFuncao (tipo1 nome1, ..., tipoN nomeN)


Na figura~\ref{fig:perfeito} temos o exemplo de uma função que
determina se um dado número é perfeito ou não. Um número inteiro
$x$ é perfeito se ele é igual à soma dos seus divisores, excetuando-se
ele mesmo. 

\begin{figure}
\begin{verbatim}
funcao ehPerfeito (inteiro x) retorna booleano
  inteiro soma = 1
  inteiro divisor = 2
  repita enquanto divisor <= x / 2
    se x mod divisor == 0
      soma = soma + divisor
    fim
    divisor = divisor + 1
  fim	

  retorne soma == x
fim

escreva(ehPerfeito(6))
escreva(ehPerfeito(9))
escreva(ehPerfeito(28))
escreva(ehPerfeito(1000))
\end{verbatim}
\caption{Função que Determina se um Número é Perfeito}
\label{fig:perfeito}
\end{figure}

\end{document}


