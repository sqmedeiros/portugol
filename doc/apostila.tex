\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{url}
\usepackage{gensymb}

\newcommand{\Qgol}{QuoGol\;}

\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{center}
%\tt{LabLua}\\
%\tt{www.lua.inf.puc-rio.br}
\end{center}
\vspace{6cm}
\Huge{Lógica de Programação}\\
\vspace{1.5cm}
\Large{Sérgio Queiroz de Medeiros} \\
\Large{Escola de Ciências e Tecnologia} \\
\Large{UFRN}
\vspace{5cm}
\\
\large{Agosto de 2016}
\end{center}

\tableofcontents

\pagebreak

%\textbf{\huge{Prefácio}}

%\vspace{1cm}


\chapter{Introdução}

Em um curso como Lógica de Programação, onde o aluno
vai começar o aprendizado de algoritmos e de programção
de computadores, é comum a utilização de uma linguagem
de programação que possa facilitar o entendimento do
assunto, ao invés de usar linguagens de programação
mais convencionais.

Geralmente uma linguagem de programação utiliza termos em inglês,
de modo que ela possa ser usada por pessoas de todo o mundo.
Contudo, o uso de termos em inglês pode dificultar o aprendizado
de alguns alunos. Por conta disso, algumas linguagens, voltadas
principalmente para o aprendizado de programação, usam termos em
português. Essas linguagens são usualmente chamadas de \emph{Portugol}.

Neste curso utilizaremos a linguagem de programação \emph{\Qgol},
cuja sintaxe foi inspirada na sintaxe da linguagem Quorum
(\url{https://www.quorumlanguage.com/}).

Com \Qgol será possível implementarmos algoritmos que envolvam
estruturas de decisão, estruturas de repetição, coleções de dados
e funções.

Para executarmos os programas escritos em \Qgol é necessário
instalar o ambiente de programação da linguagem, que está disponível em
\url{https://github.com/alex7alves/InterfaacePesquisa/tree/master/pesquisa}.


\section{Programa \emph{Olá, mundo}}

Vamos começar o nosso aprendizado com um programa \Qgol simples,
que imprime um texto:
%
\begin{verbatim}
escreva("Olá, mundo")
\end{verbatim}
%
No programa acima usamos a função \texttt{escreva},
que recebe um valor entre parênteses e o imprime para
a saída padrão do computador (o monitor, geralmente).
Nesse programa o valor recebido por \texttt{escreva}
foi um texto, delimitado por aspas duplas. Quando executado,
esse programa imprime \emph{Olá, mundo}.  

Escreva o programa acima no ambiente de programação de \Qgol,
salve o arquivo como \texttt{alo.gol} e tente executá-lo.
Use sempre a extensão \texttt{.gol} para os arquivos com
programas \Qgol.

A função \texttt{escreva} não imprime só texto, ela também
imprime valores inteiros e outros tipos de dados que veremos
mais adiante. Por exemplo, no programa a seguir a função
\texttt{escreva} recebe dois valores, um texto e o valor
inteiro 42:
%
\begin{verbatim}
escreva("A resposta é ", 42)
\end{verbatim}
%
Note que usamos uma vírgula para separar os
valores passados para a função \texttt{escreva}.


\section{Fazendo contas}

Podemos usar \Qgol como uma calculadora, onde a função
\texttt{escreva} irá imprimir o resultado de uma determinada
expressão, como no exemplo abaixo:
%
\begin{verbatim}
escreva("A resposta é ", 1 + 1)
\end{verbatim}
%
Nesse exemplo, a expressão \texttt{1 + 1} terá seu valor
calculado e então esse valor será exibido. Podemos calcular
também o resultado de expressões mais complexas:
\begin{verbatim}
escreva("A resposta é ", 3 + 4 * 5)
\end{verbatim}
% 
Nesse caso, como o operador \textbf{*} possui maior precedência
a multiplicação \texttt{4 * 5} será realizada primeiro e o seu
resultado será somado ao valor 3.
%
Para mudar a ordem em que as operações devem ser feitas podemos
usar parênteses, como no exemplo a seguir:
\begin{verbatim}
escreva("Usando parênteses ", (3 + 4) * 5, (5 + 7)  / (3 - 1))
\end{verbatim}
%
Esse programa deve imprimir os valores 35 e 6 como resultado
das operações de multiplicação e divisão, respectivamente.


\section{Variáveis}

Nos programas anteriores, fizemos operações com valores que
já estavam definidos nos próprios programas (os números $3$, $7$, etc).
Agora vamos escrever um programa que vai pedir para o usuário
digitar valores e então vai fazer operações sobre esses valores.

Para isso, precisamos usar variáveis. Uma variável é um nome associado
a uma região da memória do computador. Podemos usar esse nome para
acessar e alterar o valor armazenado nessa região de memória. 

Abaixo, temos o programa \texttt{somaInteiro.gol}, que
calcula a soma de valores inteiros digitados pelo usuário:
%
\begin{verbatim}
01  inteiro valor1, valor2, soma
02
03  escreva("Digite um valor inteiro: ")
04  leia(valor1)
05
06  escreva("Digite outro valor inteiro: ")
07  leia(valor2)
08
09  soma = valor1 + valor2
10  escreva("A soma deu ", soma)
\end{verbatim}
%
Na linha 1 declaramos as variáveis \texttt{valor1}, \texttt{valor2}
e \texttt{soma}, do tipo \textbf{inteiro}. Em \Qgol
toda variável possui um tipo, que indica a natureza dos valores que
iremos armazenar naquela variável e esse tipo deve ser declarado antes
da variável ser usada. No exemplo acima, o tipo \textbf{inteiro} indica
que iremos guardar valores inteiros, tais como 42, -255, 0 e 1000000,
nas variáveis \texttt{valor1}, \texttt{valor2} e \texttt{soma}.
 
Na linha 3, usamos a função \texttt{escreva}, que vimos anteriormente,
para pedir que o usuário forneça um valor inteiro.

Usamos a função \texttt{leia} na linha 4 para ler a informação digitada
pelo usuário e armazená-la na região de memória associada à variável
\texttt{valor1}. De modo similar, na linha 7 usamos \texttt{leia}
para guardar na variável\texttt{valor2} o segundo valor inteiro
digitado pelo usuário.

Na linha 9, usamos o operador de atribuição \textbf{=} para guardar
na variável \texttt{soma} o resultado da operação \texttt{valor1 + valor2},
que é um valor inteiro. Mais adiante iremos estudar a precedência dos
operadores, que determina que operações serão realizadas primeiro.
No caso da linha 9, primeiro será realizada a operação \textbf{+} (soma)
e depois a operação \textbf{=} (atribuição).

Em seguida, na linha 10, imprimimos um texto seguido do valor armazenado
em \texttt{soma}. 

Digite o programa \Qgol acima no seu ambiente de programação
e depois o execute. Em seguida, modifique o programa de modo que
ele imprima também o valor da subtração \texttt{valor1 - valor2}.



\section{Operadores Aritméticos e o Tipo \textbf{numero}}

Abaixo listamos os operadores aritméticos disponíveis em \Qgol,
todos possuem dois operandos:
\begin{verbatim}
+   -   *   /   mod
\end{verbatim}


O operador \textbf{/} calcula o resultado da divisão entre dois valores
$x$ e $y$. Se $x$ e $y$ são valores inteiros, então o resultado será um
valor inteiro. Por exemplo, a expressão abaixo:
\begin{verbatim}
12 / 5
\end{verbatim}
produzirá o valor 2.

Se um dos valores for um número real, como por exemplo 3.14\footnote{Note que devemos
usar o ponto ao invés da vírgula para separar a parte inteira da parte fracionária de número},
então o resultado será um número real. Por exemplo, a expressão:
\begin{verbatim}
12 / 5.0
\end{verbatim}
produzirá o valor 2.4.

Para armazenar um valor real, devemos usar uma variável do tipo
\textbf{numero}, como mostrado no exemplo abaixo:
\begin{verbatim}
01  numero x = 12 / 5
02  escreva("x = ", x)
03
04  x = 12 / 5.0
05  escreva("x = ", x)
\end{verbatim}
%
Na linha 1 declaramos a variável \texttt{x} e a inicializamos
com o valor da expressão \texttt{12 / 5}. Na linha 2 imprimimos
o valor de \texttt{x}, no caso 2. Note que uma variável do tipo
\textbf{numero} também pode guardar valores inteiros, porém uma
variável do tipo \textbf{inteiro} não pode guardar valores reais.

Na linha 4, atribuímos a \texttt{x} o valor da expressão \texttt{12 / 5.0}
e na linha 5 imprimimos o novo valor de \texttt{x}.

Enquanto o operador \textbf{/} nos dá o resultado do quociente
de uma divisão, o opererador \textbf{mod} nos dá o resto de uma
divisão. Por exemplo, o resultado da expressão
\begin{verbatim}
14 mod 5
\end{verbatim}
é 4, que representa o resto da divisão de 14 por 5.

Ao contrário dos outros operadores aritméticos, que aceitam
valores reais e inteiros, o operador \textbf{mod} somente pode
ser aplicado a operandos inteiros. 

O operador \textbf{mod} é bastante útil se desejamos saber se
um número é ou não divisível por outro. Quando um número é divisível
por outro o resultado do operador \textbf{mod} é zero.

Abaixo, temos uma adaptação do nosso programa que somava dois números
inteiros. Agora, ele imprime o resto da divisão de \texttt{x} por \texttt{y}:
%
\begin{verbatim}
01  inteiro x, y, resto
02  
03  escreva("Digite dois valores inteiros: ")
04  leia(x, y)
05 
06  resto = x mod y
07  escreva(x,  " mod ",  y, " = ", resto)
\end{verbatim}

Na linha 1 declaramos as variáveis inteiras
\texttt{x}, \texttt{y} e \texttt{resto}, e na
linha 4 fizemos a leitura dos valores de
\texttt{x} e \texttt{y}.

Na linha 6, inicializamos a variável \texttt{resto}
como o resto da divisão de \texttt{x} por \texttt{y},
e na linha 7 imprimimos o resultado.


Embora no exemplo anterior tenhamos utilizado a variável
\texttt{resto} para guardar o resultado da operação de \textbf{mod}
também é possível imprimir diretamente o resultado dessa operação,
como mostrado a seguir:
\begin{verbatim}
01  inteiro x, y
02  
03  escreva("Digite dois valores inteiros: ")
04  leia(x, y)
05 
06  escreva(x,  " mod ",  y, " = ", x mod y)
\end{verbatim}


\section{Conversão de Temperaturas}

Dado que sabemos como realizas operações aritméticas em \Qgol,
podemos escrever um programa que converte temperaturas. Em todo o
mundo as temperaturas são medidas na escala Celsius, porém nos
Estados Unidos ainda usam uma escala diferente, e medem a temperatura
em graus Fahrenheit. 

A nossa tarefa é fazer um programa que convete uma temperatura em
graus Celsius (ou centígrados) para Fahrenheit.

Não adianta tentar escrever um programa para isso se não sabemos
como converter uma temperatura entre essas duas escalas.

Na escala Celsius a água congela a 0\degree e ferve a 100\degree C,
enquanto que na escala Fahrenheit ela congela a 32\degree
e ferve a 212\degree F.

Com isso, podemos definir uma regra de conversão entre essas escalas
da seguinte maneira, onde \texttt{C} representa uma temperatura qualquer
em graus Celsius e \texttt{F} representa uma temperatura qualquer em
graus Fahrenheit:
\[
\frac{F-32}{212-32} = \frac{C-0}{100-0}  \;\;\Rightarrow\;\;  \frac{F-32}{180}  =  \frac{C}{100}
\]
Podemos dividir ambos os lados da igualdade por 20 e então obter a equação:
\[
\frac{F-32}{9} = \frac{C}{5}  \;\;\Rightarrow\;\;  F = \frac{9*C + 32}{5}
\]

Agora que sabemos como converter uma temperatura na escala Celsius para a
correspondente na escala Fahrenheit podemos escrever o nosso programa \Qgol,
que está listado na figura~\ref{fig:celsius}:

\begin{figure}
\begin{verbatim}
01  //Programa que converte de Celsius para Fahrenheit
02
03  numero tempC, tempF
04
05  escreva("Digite uma temperatura em graus Celsius: ")
06  leia(tempC)
07
08  tempF = (tempC * 9 + 32) / 5
09
10  escreva(tempC, "C  equivalem a ", tempF, "F")
\end{verbatim}
\caption{Programa que converte uma temperatura em graus Celsius para Fahrenheit}
\label{fig:celsius}
\end{figure}

Na linha 1 do programa temos um comentário de uma linha. Um comentário é indicado
por \texttt{//} e não faz parte da lógica do programa, é apenas uma informação para
o programador, muitas vezes usado para explicar o que faz um certo trecho de código.
O texto de um comentário é ignorado pelo compilador ao gerar um arquivo executável.

Na linha 3 declaramos as variáveis \texttt{tempC} e \texttt{tempF} para armazenar
os valores das temperaturas em graus Celsius e Fahrenheit, respectivamente. Note
que elas são do tipo \texttt{numero}, não do tipo \texttt{inteiro}, pois podemos
representar uma temperatura como um valor real.

Na linha 6 inicializamos a variável \texttt{tempC} com o valor fornecido pelo usuário.
Em seguida, na linha 8, convertemos a temperatura para Fahrenheit de acordo com a
equação mostrada anteriormente.

Por fim, na linha 10, imprimimos o valor da temperatura nas duas escalas.

Se fornecermos como entrada do programa a temperatura prevista para hoje em Natal,
que é de 29\degree C, ele mostrará o valor correspondente de 58.6\degree F.

Se por alguma razão dejarmos mostrar somente valores inteiros, podemos usar a função
\texttt{converteInt}, que converte um número para inteiro. Assim, a última linha do
programa anterior seria reescrita como:
\begin{verbatim}
escreva(tempC, "C  equivalem a ", converteInt(tempF), "F")
\end{verbatim}

\begin{itemize}
	\item \textbf{booleano}: representa os valores \textbf{verdadeiro} e \textbf{falso}
	\item \textbf{inteiro}: representa valores inteiros, como 101, -93 e 0.
	\item \textbf{numero}: representa valores valores reais, como 3.14, -10.4, e 42.0
	\item \textbf{texto}: representa sequências de caracteres, que deve estar entre
  aspas duplas, tais como "bola" e "ciclo básico"
\end{itemize}





% TODO: falar da função de conversão entre inteiros e reais


\section{Exercícios}

\begin{enumerate}

\item Considere que um caixa de supermercado possui notas de R\$ 50,
R\$ 20, R\$ 10, R\$ 5 e R\$ 1. Escreva um programa que lê um valor
inteiro, que representa o troco que o caixa deve dar, e calcula o
menor número de notas que o caixa deve utilizar para obter esse valor.
O programa deve mostrar o número de notas de cada valor que serão
utilizados para fornecer o troco.

\begin{verbatim}

\end{verbatim}


\end{enumerate}


\chapter{Estruturas de Controle}

\chapter{Estruturas de Repetição}



\section{Exercícios}




\section{Declaração de Array}

A forma geral para declarar um array é a seguinte: 
\begin{verbatim}
nomeDoTipo[] identificador
\end{verbatim}

No exemplo acima, apenas declaramos um array, mas não o
inicializamos. Abaixo declaramos e inicializamos um
array de inteiros com 10 elementos:
\begin{verbatim}
inteiro[] x = novo inteiro[10]
\end{verbatim}

O primeiro elemento de $x$ está no índice 1 o último
elemento no índice 10. É um erro acessar um índice do
array fora desse intervalo. Abaixo temos o exemplo de
um programa que inicializa cada posição $i$ de um array
com o $i^2$ e imprime o resultado:
\begin{verbatim}
inteiro[] a

a = novo inteiro[5]

inteiro i = 1
repita enquanto i <= 5
  a[i] = i * i
  i = i + 1
fim

i = 1
repita enquanto i <= 5
  escreva(a[i])
  i = i + 1
fim
\end{verbatim}


Devemos usar um par de \texttt{[]} para declarar cada dimensão
do nosso array, como mostrado abaixo: 
\begin{verbatim}
inteiro[][] x = novo inteiro[5][3]
\end{verbatim}

A expressão \texttt{novo inteiro[5][3]} diz que $x$ é um
array que possui 5 elementos na primeira dimensão, e cada
uma desses elementos possui 3 elementos na segunda dimensão.


\section{Funções Básicas}

\begin{itemize}
	\item \textbf{escreva (parâmetro1, parâmetro2, ..., parâmetroN)}
	
	\item \textbf{leia(parâmetro1, parâmetro2, ..., parâmetroN)}
	
	\item \textbf{inteiro textoComp (texto s)}: retorna o comprimento do texto $s$
	
	\item \textbf{texto textoSub (texto s, inteiro inicio, inteiro fim)}:
	retorna a porção do texto $s$ que começa no índice $inicio$ e termina
  no índice $fim$. O índice $fim$ é opcional, se ele não for fornecido a
  porção do texto $s$ retornada começa em $inicio$ e vai até o fim de $s$.
	
	\item \textbf{texto textoPos (texto s, inteiro inicio)}:
	retorna o texto no índice $inicio$ de $s$
\end{itemize}


\section{Declaração de Função}

Forma geral de declarar uma função: \\
\textbf{funcao} nomeFuncao (tipo1 nome1, ..., tipoN nomeN) \textbf{retorna} tipoRetorno

Caso a função não retorne nenhum valor, a última parte não é necessária e a
função pode ser declarada como: \\
\textbf{funcao} nomeFuncao (tipo1 nome1, ..., tipoN nomeN)


Na figura~\ref{fig:perfeito} temos o exemplo de uma função que
determina se um dado número é perfeito ou não. Um número inteiro
$x$ é perfeito se ele é igual à soma dos seus divisores, excetuando-se
ele mesmo. 

\begin{figure}
\begin{verbatim}
funcao ehPerfeito (inteiro x) retorna booleano
  inteiro soma = 1
  inteiro divisor = 2
  repita enquanto divisor <= x / 2
    se x mod divisor == 0
      soma = soma + divisor
    fim
    divisor = divisor + 1
  fim	

  retorne soma == x
fim

escreva(ehPerfeito(6))
escreva(ehPerfeito(9))
escreva(ehPerfeito(28))
escreva(ehPerfeito(1000))
\end{verbatim}
\caption{Função que Determina se um Número é Perfeito}
\label{fig:perfeito}
\end{figure}

\end{document}


